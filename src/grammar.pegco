
->
    { TypeString, TypeRefCall, TypeRefDecl, TypeAnything, 
        TypeNumber, TypeBoolean, TypeDate, TypeInteger, 
        TypeObject, TypeArray, ArrayRange, TypeProperty,
        Types,

        BinaryOperator,

        String, Typeumber, List, Member, Boolean, FunCall
    } = require './ast'

toplevel
    = node:(type) __? -> return node

type
    = decl:ref_decl? t:type_choice ->
        return t
    / call:ref_call

type_choice
    = __? type:type_single typearr:(PIPE t:type_single { return t; })* ->
        types = new Types!
        types.addType type
        for t of typearr
            types.addType t
        return types

type_single
    = type:(array
    / object
    / string
    / date
    / number
    / integer
    / boolean
    / anything) validation:boolean_expression? ->
        # FIXME add validation
        if validation
            type.validation = validation
        return type

ref_decl
    = AMPERSAND string_simple

ref_call
    = STAR string_simple

array
    = LBRACKET type:type? RBRACKET ->
        arr = new TypeArray type
        return arr

object
    = LBRACE props:property* RBRACE ->
        obj = new TypeObject!
        for o of props
            obj.addProperty o
        return obj
    / props:property+ ->
        obj = new TypeObject!
        for o of props
            obj.addProperty o
        return obj

property
    = __? name:string_literal  __? ":" type:type nul:nullable? att:(optional { return "optional"; } / default)?  ->
        prop = new TypeProperty name, type
        if att is \optional
            prop.setOptional!
        if att instanceof Object
            prop.setDefault def
        if nul
            prop.setNullable!
        return prop

        
    # / regexp_literal

nullable = __? "nullable"
optional = __? "optional"
default = __? "default" literal

date 
    = __? "date" -> return new TypeDate
string 
    = __? "string" -> return new TypeString
number 
    = __? "number" -> return new TypeNumber
integer 
    = __? "integer" -> return new TypeInteger
boolean 
    = __? "boolean" -> return new TypeBoolean
anything
    = __? "anything" -> return new TypeAnything

boolean_expression
    = l:expression op:(AND / OR) r:boolean_expression ->
        op.left = l
        op.right = r
        return op
    / LPAREN exp:boolean_expression RPAREN -> return exp
    / exp:expression ->
        return exp

/**
 *
 */
expression
    = expression_op
    / left:literal op:expression_op ->
        op.left = left
        return op

expression_op
    = op:(IN / NOT op:IN { op.negated = true; return op; } ) container:(list / member / function_call) ->
        op.right = container
        return op
            
    / op:(op:IS NOT { op.negated = true; return op; } / IS) r:literal ->
        op.right = r
        return op
        
    / op:COMP_OP r:literal ->
        op.right = r
        return op

COMP_OP = LTE / GTE / LT / GT

/**
 *
 */
literal
    = __? lit:( function_call
          / number_literal
          / string_literal
          / list
          / member
          / boolean_literal
          / null ) -> return lit

/**
 *
 */
list
    = LPAREN lits:(li:literal { return li; })+ RPAREN ->
        return new List lits

string_literal
    = "'" str:("\\'" / [^\'])* "'" -> return new String str.join ""
    / '"' str:("\\\"" / [^\"])*  '"' -> return new String str.join ""
    / str:string_simple -> return new String str

boolean_literal
    = TRUE / FALSE

/**
 *  FIXME: member should have a nice syntax !
 */
member
    # FIXME should be better !
    = DOLLAR ->
        return new Member \$

/**
 *  A function call.
 */
function_call
    = name:string_regular LPAREN member RPAREN ->
        # FIXME should be able to give arguments
        return new FunCall name.str, [new Member \$]
    / name:string_regular EXCLAMATION ->
        return new FunCall name.str, [new Member \$]

/**
 *  A simple string for label matching.
 */
string_simple
    = __? f:[^:\t\+\n\(\) ] s:[^:\t\+\n\) ]+ -> 
        str = f + s.join ""
        return str

/**
 *  A string as encountered in regular programming languages.
 */
string_regular
    = __? f:[a-zA-Z_] s:[a-zA-Z_0-9]+ ->
        str = f + s.join ""
        return new String str

number_literal
    = n:[0-9]+ comma:("." e:[0-9]+ { return '.' + e.join(""); })? ->
        n = (n.join "") + comma
        return new Number n

integer
    = __? number:[0-9]+ -> return number.join ""

null
    = "null"

# comments !
__
    = (
    whitespace? "#" [^\n]* "\n"
    / whitespace
    / '\n' )+ -> return ""

whitespace 
    = (" " / "\t")+

AMPERSAND   = __? "&"
LBRACKET    = __? "["
RBRACKET    = __? "]"
LBRACE      = __? "{"
RBRACE      = __? "}"
STAR        = __? "*"
PLUS        = __? "+"
COMMA       = __? ","
LPAREN      = __? "("
RPAREN      = __? ")"
AROBAS      = __? "@"
DOLLAR      = __? "$"
PIPE        = __? "|"
EXCLAMATION = __? "!"
SHARP       = __? "#"

IN          = __? "in" { return BinaryOperator["in"](); }
NOT         = __? "not"
IS          = __? "is" { return BinaryOperator.is(); }
MATCHES     = __? "matches" { return BinaryOperator.matches(); }

GT          = __? o:">" { return BinaryOperator.gt(); }
LT          = __? o:"<" { return new BinaryOperator.lt(); }
LTE         = __? o:"<=" { return new BinaryOperator.lte(); }
GTE         = __? o:">=" { return new BinaryOperator.gte(); }

TRUE        = __? "true" { return new Boolean(true); }
FALSE       = __? "false" { return new Boolean(false); }
AND         = __? "and" { return new BinaryOperator.and(); }
OR          = __? "or" { return new BinaryOperator.or(); }

