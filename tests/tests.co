#!/usr/bin/env coco
vows = require \vows
{ join } = require \path
{ walk } = require \rbuild
{ readFileSync, stat } = require \fs
{ argv }: optimist = require \optimist
    .usage "$0: run the test suite."
    .alias \verbose, \v
    .alias \help, \h
    .describe \verbose, "Show all the tests"
    .describe \help, "You're staring at it"
{ spawn } = require \child_process
{ doesNotThrow, equal, notEqual } = require \assert
{ parallel } = require \async

{ parse } = require '../lib/grammar'
{ printVisitor, pythonVisitor } = require '../lib/vst'

function execPython (python_code, json, done)
    code = """
        from validatr import *
        #python_code
        from simplejson import loads
        o = loads('''[ #json ]''')

        for obj in o:
            print unicode(validator.validate(obj)) + " : -" + unicode(obj) + "-"
        """

    cp = spawn "python", ['-c', code]

    stdout = ''
    stderr = ''
    cp.stdout.on \data, (data) ->
        stdout := stdout + data
    cp.stderr.on \data, (data) ->
        stderr := stderr + data

    cp.on \exit, ->
        done null, { stdout, stderr }


parseTests = vows.describe "Parsing Tests"
parseBatch = {}

if argv.v
    reporter = require \vows/lib/vows/reporters/spec
else
    reporter = require \vows/lib/vows/reporters/dot-matrix

function intent (cbk)
    try
        return cbk!
    catch e
        return null

walk "#__dirname", /.*\.vld$/, ((abs, rel) ->

    file = readFileSync rel, \utf-8
    [ vld, valid ? "", invalid ? "" ] = file.split '---'

    valid = valid.trim!
    invalid = invalid.trim!
    vld = vld.trim!

    parsed_vld = null
    python_code = null

    intent -> parsed_vld := parse vld
    intent -> python_code := pythonVisitor.visit parsed_vld

    test = parseBatch[rel] =
        topic: ->
            (err, results) <~ parallel do
                valids: (cbk) ->
                    if not valid
                        cbk null
                        return
                    execPython python_code, valid, cbk
                invalids: (cbk) ->
                    if not invalid
                        cbk null
                        return
                    execPython python_code, invalid, cbk
            @callback err, results
                    

        "can be parsed without error": ->
            notEqual parsed_vld, null

        "can be printed and re-printed": ->
            res1 = ""

            doesNotThrow function testPrint
                res1 := printVisitor.visit parsed_vld

            doesNotThrow function testRePrint
                res2 = parse res1
                equal res1, printVisitor.visit res2

    if parsed_vld
        test."compiles to python without error": (data) ->
            notEqual python_code, null

    if python_code
        if valid
            test."python valids (#valid)" = ({ valids }) ->
                { stdout, stderr } = valids
                equal stderr, ''
                equal (stdout.replace /^True.*$/mg , '' .replace /\n/g, ''), ''

        if invalid
            test."python invalids (#invalid)" = ({ invalids }) ->
                { stdout, stderr } = invalids
                equal stderr, ''
                equal (stdout.match /^True.*/m), null


    ), ->
        parseTests.addBatch parseBatch
        parseTests.run reporter: reporter
